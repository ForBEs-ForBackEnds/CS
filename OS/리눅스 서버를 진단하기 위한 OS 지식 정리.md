### **목차**
- [가상 메모리(논리적 메모리)](#가상-메모리(논리적-메모리))
    - [메모리는 프레임 단위, 프로세스는 페이지 단위](#메모리는-프레임-단위,-프로세스는-페이지-단위)
        - [실제 주소를 찾는 과정을 줄이기 위한 방법, TLB](#실제-주소를-찾는-과정을-줄이기-위한-방법,-tlb)
    - [가상 메모리는 주 기억 혹은 보조 기억의 메모리를 사용](#가상-메모리는-주-기억-혹은-보조-기억의-메모리를-사용)
- [프로그램 실행단계](#프로그램-실행단계)
    - [PCB](#pcb)
- [물리 메모리에 원하는 페이지가 없을 경우, page fault](#물리-메모리에-원하는-페이지가-없을-경우,-page-fault)
    - [Thrashing](#thrashing)
- [참고 자료](#참고-자료)

# 가상 메모리(논리적 메모리)

CPU가 연산을 수행할 때, 참조하는 주소 값은 실제 RAM에 적재되어 있는 프로세스의 주소를 가리키고 있지 않는다. 이를 이해하기 위해선 먼저 가상 메모리와 페이징 기법을 알아야 한다.

가상 메모리는 논리 메모리라고도 부른다. 이와 반대되는 말은 물리 메모리로 실제 RAM을 뜻한다.
OS는 각 프로세스가 독립적으로 메모리 공간을 사용할 수 있도록 하며, 이들이 서로에게 영향을 주지 않도록 한다.

## 메모리는 프레임 단위, 프로세스는 페이지 단위

메모리는 프레임(Frame)이라는 단위로 나뉘어진다. 프로세스는 페이지(Page)라는 단위로 나뉘어진다. 즉, 하나의 프로세스가 존재할 때, 이는 페이지 단위로 분할되어 메모리의 프레임에 각각 배치된다. 이 때, 하나의 프로세스에서 분할된 각각의 페이지들은 연속적으로 메모리에 위치하지 않을 수 있다.

![](https://i.imgur.com/jbpZfhq.png)
refs) https://www.geeksforgeeks.org/difference-between-paging-and-segmentation/

주 기억장치(Main Memory, RAM)는 Frame 단위로 이루어져 있으며, 프로세스는 Page 단위로 이루어져 있다.

![L0IY5wp.png|595](https://i.imgur.com/L0IY5wp.png)
refs) https://www.geeksforgeeks.org/virtual-address-space-in-operating-system/

CPU가 참조하는 메모리 주소는 실제 메모리 주소가 아닌 가상 메모리 주소 값이라고 하였다. 그러면 실제 메모리 주소에 값을 불러오기 위해서는 가상 메모리 주소와 실제 메모리 주소를 매핑하는 정보가 필요하다. 이러한 매핑정보가 담겨있는 것을 **페이징 테이블**이라고 하며, 이는 각 프로세스마다 존재하고, 실제 메모리에 저장되어 있다.

### 실제 주소를 찾는 과정을 줄이기 위한 방법, TLB

우리는 앞서, 가상 메모리의 페이지와 실제 메모리의 프레임을 매핑하는 정보를 담고있는 **페이징 테이블이 실제 메모리에 저장되어 있다고 하였다.** 그렇다면, 실제 메모리를 가져오려면 실제 메모리에 두 번 접근해야 한다. (페이징 테이블이 저장된 곳 + 실제 메모리 주소) 이러한 단점을 해결함으로써 성능을 개선하기 위한 방법으로 캐시를 활용하는데, **이를 TLB라고 한다.** TLB는 특정 페이지의 번호와 프레임 번호를 매핑하고 있는 테이블 구조이다.

- TLB에 원하는 Page가 있을 때(이를 **hit라고 한다**) : 실제 메모리에 **한 번만** 접근
- TLB에 원하는 Page가 없을 때(이를 **miss라고 한다**) : 실제 메모리에 **두 번** 접근

참고로, TLB에 저장된 값들은 현재 CPU를 사용하고 있는 프로세스에 대한 정보가 담겨있다. 따라서 컨텍스트 스위칭이 발생할 경우, TLB에 스위칭된 프로세스의 내용들을 다 비워야 한다. (flush, remove old entries)

## 가상 메모리는 주 기억 혹은 보조 기억의 메모리를 사용

가상 메모리는 각 프로세스마다 존재하며, 페이지 단위로 구성된다. 이 때, 가상 메모리의 각 페이지는 주 기억장치인 RAM 혹은 보조 기억장치인 SSD/HDD에 존재할 수 있다. OS는 프로세스에서 주로 사용되는 부분을 RAM에 두고, 잘 사용하지 않거나 사용되지 않는 페이지는 보조 기억장치에 옮긴다. 자주 사용이 된다는 것은 CPU가 참조하는 횟수가 많다는 뜻이기에 RAM에 위치하는게 성능 상에 더 이점이 많다. 반대로 참조되지 않아 소외되는 영역은 속도는 느리지만 공간이 많은 보조 기억장치에 위치하는게 더욱 합리적이며, RAM을 효율적으로 사용할 수 있는 방법이다.

이처럼 **가상 메모리를 활용할 때, RAM이 아니라 SSD/HDD 같은 보조 기억장치에 페이지를 위치할 수 있게 되는데, 이 때 이 보조 기억장치를 Swap 영역이라고 한다.** 한 번 RAM에 위치한 페이지는 계속 있지 않는다. 이들도 언젠가 CPU로부터 외면당한다면 언제든지 Swap 영역으로 이동할 수 있다. CPU에게 관심을 얻게된 페이지를 Swap 영역에서 RAM 공간으로 이동시키는 것을 **Swap In**, 반대로 CPU에게 외면 받은 페이지가 RAM 공간에서 Swap 영역으로 추방당하는 것을 **Swap Out**이라고 한다.

# 프로그램 실행단계

프로세스는 각각의 가상 메모리를 갖고 있다고 하였다. 따라서 우리가 자주 접하는 Stack, Heap, Code, Data 영역으로 나뉘어져 있는 메모리 그림들은 모두 가상 메모리라고 생각하면 된다.
(이들을 나타내는 그림들은 다 일렬로 연결되어 있음 -> 실제 메모리에서는 연속적으로 배치될 확률이 적음)

OS도 결국엔 하나의 프로그램이다. 따라서 컴퓨터가 부팅되었을 때, 이들도 하나의 프로세스로 동작한다. 즉, 이들도 가상 메모리를 갖게 된다는 뜻이다. 우리가 User Mode와 Kernel Mode를 구분하였을 때, 이 Kernel Mode에 해당하는 부분이 바로 OS가 프로세스로 동작할 때, 점유하는 가상 메모리 공간이라고 할 수 있다.

![](https://i.imgur.com/SlkZPxV.png)
(필자가 반효경 교수님의 KOCW 운영체제를 들으며 정리한 그림)

컴퓨터로 직접 그리기 번거로워서 예전에 태블릿으로 그렸던 내용을 사용하여 설명하겠다.
보조 기억장치에 저장된 프로그램을 실행하게 되면, 이들은 각각의 가상 메모리가 페이지 단위로 구성되며, 이들 중 실행에 필요한 부분은 RAM에 그 이외 부분은 Swap 영역으로 이동한다. **이렇게 각각의 가상 메모리를 가짐과 동시에 실제 메모리에 일부 적재되어 CPU에 의해 실행될 수 있는 프로세스가 되는 것을 인스턴스화라고 한다.**

![](https://i.imgur.com/E0ImMdG.png)

refs) 인프런 "인프라 공방" 강의 교안 중 일부

이처럼 각 프로세스마다 연속적인 메모리 공간을 가지며, 프로세스별로 독립된 메모리 공간을 갖게 되는데 이 또한 가상 메모리이기에 가능한 것이다. 또한 가상 메모리는 User Mode와 Kernel Mode로 나뉘어지며, Kernel Mode에도 마찬가지로 Data, Code 영역 등이 존재한다.

사용자가 정의 or 라이브러리 함수들은 User Mode의 프로세스 Code 영역에 존재하며, 운영체제의 커널 함수는 Kernel Mode의 Code 영역에 존재한다. (위 그림 참고)

따라서 사용자가 정의한 코드를 실행할 때는 User Mode로, 커널 함수를 호출하는 시스템 콜이 발생할 경우 Kernel Mode로 OS가 동작하게 되는 것이다.

![](https://i.imgur.com/klzhCYv.png)
(필자가 반효경 교수님의 KOCW 운영체제를 들으며 정리한 그림2)

## PCB

![](https://i.imgur.com/RmnQfqA.png)
refs) 인프런 "인프라 공방" 강의 교안 중 일부

여러 프로세스가 번갈아 수행되며, 마치 동시에 실행되는 것처럼 보이도록 하는 것을 **동시성**이라고 하였다. OS는 하나의 코어가 여러 프로세스를 수행할 수 있도록 프로세스에게 CPU를 일정 시간 할당한 후, 다시 다른 프로세스에게 할당하도록 제어한다. 이러한 컨텍스트 스위칭이 발생할 때, 각각의 작업 상태를 저장하고 다시 Kernel의 Ready Queue에서 불러올 수 있어야, 컨텍스트 스위칭에 의해 중단됐던 프로세스를 다시 이어서 실행할 수 있을 것이다. 이처럼 **OS가 프로세스의 상태를 저장하는 데이터 구조를 PCB(Process Control Block)이라고 한다.** 이러한 PCB는 Kernel의 Ready Queue(준비 큐)에 저장되어, 관리된다.

![](https://i.imgur.com/HSJrLVh.png)

- Process ID(PID) : 각 프로세스는 고유의 ID를 갖는다.
- Program Counter(PC) : 프로세스가 CPU를 할당받고 실행되어야 할 명령어의 주소를 가리킨다.
- CPU Registers : 프로세스 복구에 필요한 상태 값들을 저장한다. (ex. 스택 포인터 : 실행되어야 할 스레드의 스택 메모리의 최상단 주소 값을 가리킴)

# 물리 메모리에 원하는 페이지가 없을 경우, page fault

가상 메모리 시스템을 도입하게 되면서, 프로세스는 **페이지** 단위로 나뉘어져, 실제 메모리의 **프레임**에 적재된다. 허나, CPU가 참조해야 하는 메모리 주소가 실제 메모리에 존재하지 않는다면, Swap 영역(보조 기억장치)에서 페이지를 가져와야 한다.(Swap in) 이처럼 실제 메모리에 페이지가 존재하지 않는 경우를 **page fault**라고 한다.

만약, Swap in이 잦다면(page fault가 높다면) 보조 기억장치로부터 페이지를 가져오는 I/O 작업이 필요하게 되며, 그만큼 시간이 소요된다. page fault가 높을 경우, OS는 계속해서 Swap 영역에서 페이지를 가져와 프레임에 적재하게 될 것이고, 실제 메모리의 가용량은 줄어들 것이다.

그렇게 실제 메모리가 가득 차게 되었을 때, 또 다시 page fault가 발생한다면 기존에 존재하는 프레임 내 페이지를 원하는 페이지와 교체해야 한다. 이를 page replacement라고 한다.

## Thrashing

page fault와 page replacement가 반복될 경우, 계속해서 다양한 프로세스의 프레임이 실제 메모리에 적재될 것이다. 기존에 있던 페이지가 다른 페이지로 교체되기 때문에 실제 메모리에 존재하는 페이지의 프로세스 종류도 다양해질 것이다. 즉, 하나의 프로세스가 실제 메모리에서 차지하는 페이지 개수가 줄어들며, 이는 Frame 점유율이 낮아짐을 의미한다. 이는 또 다시 page fault의 발생률을 증가시키게 된다.

모든 프로세스들의 페이지가 서로 교체되는 I/O 작업이 많아지게 되므로, CPU 사용량은 점점 줄어들 것이다. 이 때, OS는 CPU 사용량을 늘리기 위해 더 많은 프로세스의 페이지를 실제 메모리에 적재하는 작업을 하게 된다.(최대한 빈 Frame을 많이 확보해야 하는 상황임에도 불구하고, 반대로 메모리에 계속 페이지를 적재하려고 함) 이처럼 **page fault 발생률이 높아짐에 따라 CPU 사용량이 줄어드는 것을 Thrashing이라고 한다.**

Thrashing은 메모리의 용량이 적거나 혹은 느리거나 또는 메모리 I/O 작업(Swap In, Out)이 많을 경우, 발생할 수 있다. 따라서 서버 상태를 진단하여 적절한 스펙을 결정하는 것이 중요하다.

# 참고 자료
1. [인프라 공방](https://www.inflearn.com/course/%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B3%B5%EB%B0%A9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0/dashboard)